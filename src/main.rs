#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] use eframe::CreationContext;
use eframe::egui;
use egui::FontFamily::Proportional;
use egui::FontId;
use egui::TextStyle::*;
use message_io::network::Endpoint;
use message_io::node::NodeHandler;
use message_io::node::NodeListener;
use sysinfo::{System, SystemExt, CpuExt, DiskExt, Disk};
use std::time::Duration;
use serde::{Serialize, Deserialize,};
use message_io::node::{self, NodeEvent};
use message_io::network::{NetEvent, Transport};
use std::thread;
use std::sync::{Arc, Mutex};


fn update_hardware(state_clone: Arc<Mutex<State>>, mut sys: System) {
    loop {
        sys.refresh_all();
        let hw = Hardware::new(&sys);
        let duration = 1000;
        std::thread::sleep(std::time::Duration::from_millis(duration));
        state_clone.lock().unwrap().duration = duration;
        state_clone.lock().unwrap().hw = hw;
        let ctx = &state_clone.lock().unwrap().ctx;
        match ctx {
            Some(x) => x.request_repaint(),
            None => panic!("error in Option<>"),
        }
    }
}


struct State {
    duration: u64,
    ctx: Option<egui::Context>,
    hw: Hardware
}


impl State {
    pub fn new(sys: System) -> Self {
        Self {
            duration: 0,
            ctx: None,
            hw: Hardware::new(&sys)
        }
    }
}


#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
struct DiskData {
    disk_name: String,
    disk_total: f32,
    disk_available: f32
}


impl DiskData {
    fn new(disk: &Disk) -> DiskData {
        DiskData {
            disk_name: disk.mount_point().to_str().unwrap().to_owned(),
            disk_total: (disk.total_space() as f32 / 1_073_741_824f32).ceil(),
            disk_available: (disk.available_space() as f32 / 1_073_741_824 as f32).ceil()
        }
    }
    
    fn build(sys: &System) -> Vec<DiskData> {
        sys.disks().iter()
                   .map(|d| DiskData::new(d))
                   .collect()
    }
}


// TODO Add ram percent
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
struct Hardware {
    cpu_type: String,
    cpu_count: i32,
    cpu_freq: f32,
    cpu_usage: f32,
    ram_total: f32,
    ram_usage: f32,
    disks: Vec<DiskData>
}


impl Hardware {
    fn new(sys: &System) -> Hardware {
        Hardware { 
            cpu_type: sys.global_cpu_info().brand().trim().to_owned(), 
            cpu_count: sys.cpus().len() as i32, 
            cpu_freq: (sys.cpus().iter().map(|c| c.frequency()).sum::<u64>() as f32 / sys.cpus().len() as f32).ceil(),
            cpu_usage: (sys.cpus().iter().map(|c| c.cpu_usage()).sum::<f32>() / sys.cpus().len() as f32).ceil(),
            ram_total: (sys.total_memory() as f32 / 1_073_741_824 as f32).ceil(), 
            ram_usage: (sys.used_memory() as f32 / 1_073_741_824 as f32), 
            disks: DiskData::build(&sys)
        }
    }
}


enum Signal {
    SendData,
    Disconnect
}


#[derive(Serialize, Deserialize)]
#[serde(tag = "event", rename_all = "SCREAMING-KEBAB-CASE")]
enum Event {
    #[serde(rename_all = "kebab-case")]
    Connect { client_type: String, client_name: String }, 
    #[serde(rename_all = "kebab-case")]
    Disconnect { client_type: String, client_name: String }, 
    HardwareData(Hardware),
    HardwareRequest,
    HardwareTerminate
}


fn websocket(server:Endpoint, handler:NodeHandler<Signal>, listener:Option<NodeListener<Signal>>) {
    thread::spawn(move || {
        let init_connect = Event::Connect { 
            client_type: "SERVICE".to_string(), 
            client_name: "hardware".to_string()
        };

        let mut clients:u32 = 0;
        let mut sys = System::new_all();    
        listener.unwrap().for_each(move |event| match event {
            NodeEvent::Network(net_event) => match net_event {
                NetEvent::Connected(_endpoint, _ok) => {
                    handler.network().send(server, serde_json::to_string(&init_connect).unwrap().as_bytes());
                }
                NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
                NetEvent::Message(_endpoint, data) => {
                    let data = String::from_utf8_lossy(data);
                    if let Ok(ok_data) = serde_json::from_str::<Event>(&data) {
                        match ok_data {
                            Event::HardwareRequest => {
                                clients += 1;
                                if clients == 1{
                                    handler.signals().send(Signal::SendData)
                                }
                            }
                            Event::HardwareTerminate => {
                                clients -= 1;
                            }
                            _ => {}                            
                        }
                    }
                },

                NetEvent::Disconnected(_endpoint) => (),
            }
            NodeEvent::Signal(signal) => match signal {
                Signal::SendData => {
                    sys.refresh_all();
                    let hw = Hardware::new(&sys);
                    if clients != 0 {
                        handler.signals().send_with_timer(Signal::SendData, Duration::from_secs(1));
                        handler.network().send(server, serde_json::to_string(&Event::HardwareData(hw)).unwrap().as_bytes());
                    }
                }

                Signal::Disconnect => {
                    let disconnect = Event::Disconnect { 
                        client_type: "SERVICE".to_string(), 
                        client_name: "Server".to_string()
                    };
                    handler.network().send(server, serde_json::to_string(&disconnect).unwrap().as_bytes());
                    handler.stop()
                }
            }
        });
    });
}


fn main() -> Result<(), eframe::Error> {
    tracing_subscriber::fmt::init();
    const WIDTH: f32 = 800.0;
    const HEIGHT: f32 = 400.0;

    let options = eframe::NativeOptions {
        min_window_size: Some(egui::vec2(WIDTH, HEIGHT)),
        initial_window_size: Some(egui::vec2(WIDTH, HEIGHT)),
        ..Default::default()
    };

    eframe::run_native(
        "Hardware Client",
        options,
        Box::new(|ctx| Box::new(MyApp::new(ctx, WIDTH, HEIGHT))),
    )
}

struct MyApp {
    ip: String,
    freq: u32,
    connected: bool,
    handler: NodeHandler<Signal>,
    listener: Option<NodeListener<Signal>>,
    width: f32,
    height: f32,
    state: Arc<Mutex<State>>, 
    conn_success: Option<bool>

}

impl MyApp {
    fn new(ctx: &CreationContext, width:f32, height:f32) -> Self {
        let (handler, listener) = node::split();

        let state = Arc::new(Mutex::new(State::new(System::new_all())));
        state.lock().unwrap().ctx = Some(ctx.egui_ctx.clone());
        let state_clone = state.clone();

        std::thread::spawn(move || {
            let sys = System::new_all();
            update_hardware(state_clone, sys);
        });

        Self {
            ip: "192.168.1.138".to_owned(),
            freq: 1,
            connected: false,
            handler,
            listener: Some(listener),
            width,
            height,
            state,
            conn_success: None
        }
    }

    fn re_init(&mut self) {
        let (handler, listener) = node::split();
        self.handler = handler;
        self.listener = Some(listener);
    }
}

impl eframe::App for MyApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
        let mut style = (*ctx.style()).clone();
        style.text_styles = [
            (Heading, FontId::new(30.0, Proportional)),
            (Name("Heading2".into()), FontId::new(25.0, Proportional)),
            (Name("Context".into()), FontId::new(20.0, Proportional)),
            (Body, FontId::new(18.0, Proportional)),
            (Monospace, FontId::new(14.0, Proportional)),
            (Button, FontId::new(14.0, Proportional)),
            (Small, FontId::new(10.0, Proportional)),
        ].into();
        ctx.set_style(style);

        egui::Grid::new("ui_grid")
            .num_columns(4)
            .max_col_width(self.width / 2.0 - 15.0)
            .max_col_width(10.0)
            .max_col_width(self.width / 2.0 - 15.0)
            .min_row_height(self.height / 8.0)
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    ui.label("Server IP:");
                    ui.text_edit_singleline(&mut self.ip);
                });

                ui.label("");
                ui.label("CPU:");
                ui.label(format!("{}", self.state.lock().unwrap().hw.cpu_type));

                ui.end_row();

                ui.horizontal(|ui| {
                    let _ip_label = ui.label("Frequency (Seconds): ");
                    ui.add(egui::Slider::new(&mut self.freq, 0..=120));
                });

                ui.label("");
                ui.label("CPU Frequency:");
                ui.label(format!("{}mHz", self.state.lock().unwrap().hw.cpu_freq));
                ui.end_row();

                ui.label("");
                ui.label("");
                ui.label("CPU Usage:");
                ui.label(format!("{}%", self.state.lock().unwrap().hw.cpu_usage));
                ui.end_row();

                ui.label("");
                ui.label("");
                ui.label("Ram Total:");
                ui.label(format!("{}gb", self.state.lock().unwrap().hw.ram_total));
                ui.end_row();

                for d in self.state.lock().unwrap().hw.disks.iter() {
                    ui.label("");
                    ui.label("");
                    ui.label(format!("Space Available on: {:?}", d.disk_name));
                    ui.label(format!("{}gb", d.disk_available));
                    ui.end_row();
                }

                ui.add_space(20.0);
                if !self.connected {
                    let button = ui.add_sized([120., 40.], egui::Button::new("Connect"));
                    if button.clicked() {
                        let server = match self.handler.network().connect_sync(Transport::Ws, format!("ws://{}:8081/ws/stats", self.ip)) {
                            Ok((server, _)) => {
                                self.conn_success = Some(true);
                                server    
                            }
                            Err(_) => {
                                self.conn_success = Some(false);
                                return;
                            }
                        };

                        websocket(server, self.handler.clone(), self.listener.take());
                        self.connected = true;
                    }
                } else {
                    let button = ui.add_sized([120., 40.], egui::Button::new("Disconnect"));
                    if button.clicked() {
                        self.handler.signals().send(Signal::Disconnect);
                        self.connected = false;
                        self.re_init();
                        self.conn_success = None;
                    }
                }
                ui.label("");
                match self.conn_success {
                    Some(succeeded) => {
                        if succeeded {
                            ui.label("Connected to server");
                        } else {
                            ui.label("No response from server");
                        }
                    }
                    _ => {}
                }
            });
        });
    }
}
